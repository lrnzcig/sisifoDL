post 1
======

# Pulsioximeter early alarm system using Deep Learning

## Introduction & purpose

This post presents some promising results of an early alarm model for pulsioximeter data using Deep Learning.

What's the purpose of the early alarm model? Detecting that a desaturation is likely to happen in the next 2 minutes.
(A desaturation means a low blood oxygen concentration). The output of such a model is useful on itself, at least as an initial
step for a system that improves the sleep quality of sleep of the patient (e.g. if the desaturation alarm was 
raised early enough, the carer of the patient could just change the position of the patient -assuming a patient that 
is sleeping and has very limited ability to move).

On the other hand, importantly for the purposes of this blog, it is a nice practical case of implementation of a Deep
Learning model; the task at hand is certainly cumbersome, however there is a number of steps to follow that are pretty much
common knowledge for the Deep Learning community, and after some effort, quite a lot of CPU time, and a few tricks, the
results are quite satisfying.

### Dataset used

The dataset has already been presented at [this previous post](http://sisifospage.tech/2017-05-15-time-series-clustering-pulsi.html).

It consists of data from a pulsioximeter (i.e. a device for measuring bood oxygen concentration and pulse rate). The meter was
connected to a sick patient for 39 nights, plus 2 additional nights that were recorded for a healthy patient, as a sanity check.

The capturing itself was done using software in [this repository](https://github.com/Iukekini/Baby-Monitor-Masimo-Pulse-Oximeter).

### References

There's so many references for Deep Learning. [This](https://www.business-science.io/timeseries-analysis/2018/04/18/keras-lstm-sunspots-time-series-prediction.html) 
and [this](https://www.business-science.io/timeseries-analysis/2018/07/01/keras-lstm-sunspots-part2.html)
are two parts of a quite a good tutorial for predicting a time series with LSTMs; may be a introduction. The problem 
described in the this tutorial is quite a good example since it can be reasonably dealt with the use of Deep Learning. There are
many other examples of exercises that are indeed good for practising but in a very difficult setup, such as predicting a time
series for the stock exchange market. Those exercises usually try a prediction for just 1 timestep, and the prediction might be
decent enough, but it all becomes a lot harder when adding more timesteps. A useful example for this kind of post is 
[this one](http://rwanjohi.rbind.io/2018/04/05/time-series-forecasting-using-lstm-in-r/), which by the way predicts long term
interest rates for the USA. 

There has been quite a few attempts to use Deep Learning to predict signals in similar kind of prediction setups; the
implementation in this post is actually a refactor of [this repository](https://github.com/NLeSC/mcfly) for Human Activity
Recognition, which is an implementation of [this paper](https://www.mdpi.com/1424-8220/16/1/115/htm), co-written by 
[F Ordoñez](https://www.youtube.com/watch?v=7gsIkXpZx9E) -the talk is in Spanish, sorry.

The refactored code is available [here](https://github.com/lrnzcig/sisifoDL), and mostly adds a `Data Generator` for setting up
the data more easily and, importantly, for controlling how data is fed to training the model.

If these are still not enough, you could backup to couple of references such as [Chollet's bible](https://www.manning.com/books/deep-learning-with-python) 
or [Ng's reference course](https://www.coursera.org/specializations/deep-learning)

## Summary of results

In this post, with the intention of keeping it brief (i.e. less long) and useful, only the most important results are presented
(together with the code to reproduce them). In follow-up posts, other details will be covered in more depth, so that at the end,
hopefully, the set of post would be a good summary on the steps to build up a Deep Learning model for a time series prediction.

In the following paragraphs it is assumed that the right architecture and hyperparameters have been found already, but during
training of the model the data is fed in different ways:
- Using data as it is (naïve approach)
- Rebalancing data, since it is by far more interesting to detect big desaturations, rather than spurious variations of the
oxygen levels
- Augmenting the data, i.e. producing more data from the already existing data by means of simple variations

To concluide the post, at the bottom, a brief wrap-up on what has been done, what is missing, and what will be covered in
following posts.

### Deep Learning results for the most naïve approach

In this case, data is fed to the model "as is". 

xxx

The results are not very useful though. Even for a well-tuned architecture, output predictions are not really useful, even if
they are more or less accurate most of the time. Most of the time the patient is more or less ok, the series shows small 
variations, and it does not really matter if the prediction follows those variations. However there is a few times during the
night in which the patient desatures, the oxygen level slopes down abruptly, and those are the situations to predict for the
early alarm system. 

### Deep Learning results when rebalancing data



### Deep Learning results when augmenting data

## Next steps for the model and follow-up posts




Pasos principales:
Preparar el generador de datos
Pruebas iniciales (ajuste sin variables explicativas, baseline de comparación, etc)
Búsqueda de arquitectura óptima con búsqueda de hiperparámetros “aleatoria” (ejecutar en GPU en la nube, las pruebas pueden costar horas o días y requieren memoria)
Aumentar gradualmente la complejidad de la red (1º solo RNN, después también con CNN, e ir añadiendo capas)


Conclusiones: cuándo usarlo
Con pocos datos de entrenamiento, último recurso cuando otras metodologías han fallado.
Cuando las variables explicativas tienen poco poder predictivo. Comprobar primero un ajuste sin variables explicativas (el resultado puede ser sorprendente)
Si ok, añadir variables explicativas y buscar hiperparámetros de modelo óptimo 
¿Merece la pena, en comparación con la posibilidad de incorporar nuevas variables?

Con muchos datos de entrenamiento, mejora la expectativa de obtener un buen resultado, sobre todo si la serie a predecir tiene autocorrelación alta.






CV prophet
==========
#' cross-validation loop
#' ajusta modelo con forward chaining y obtiene métricas de precisión
#' 
#' @param data daframe completo (train+test)
#' @param horizon horizonte de la predicción (número de pasos)
#' @param number_of_folds número de particiones para forward chaining
#' @param model.funcion función que ajusta el modelo a partir de df de entrenamiento
#' @param do.plot si a TRUE, hace plot de predicciones
#' @param verbose si a TRUE muestra mensajes
#' @param debug si a TRUE muestra mensajes para depuración, difíciles de entender
#' @return dataframe con MAPEs de cada uno de los folds
prophet.cv.loop <- function(data,
                            horizon,
                            number_of_folds,
                            model.function,
                            do.plot=TRUE,
                            verbose=TRUE,
                            debug=TRUE) {
  mape_v <- c()
  for (fold in 1:number_of_folds) {
    # construct data_train/data_test
    l <- nrow(data) - fold*horizon
    if (debug) print(l)
    data_train <- data[1:l,]
    data_test <- data[(l+1):(l+horizon),]
    # fit model & predict
    model <- model.function(data_train)
    forecast <- predict(model, rbind(data_train, data_test))
    if (do.plot) {
      # plot
      plot(forecast %>%
             select(ds, yhat), col="blue", type="l")
      lines(data_test %>% 
              select(ds, y), col="red", type="l")
    }
    # evaluation
    errors <- data_test$y-forecast[(l+1):(l+horizon),]$yhat
    mape <- mean(abs(errors)/data_test$y)*100
    mape_v <- c(mape_v, mape)
    if (verbose) print(paste0("fold ", fold, ": mape ", mape))
  }
  return(data.frame(mape=mape_v))
}




# BLUCLES CV PARA SELECCION DE PRIORS

# 0. test de la función CV
prophet.cv.loop(tb_weekly_base %>% 
                  mutate(Fecha=as.POSIXct(Fecha)) %>%
                  select(ds=Fecha, y=ventas_online_uds,
                         otros_precio_medio, trafico_web_sesiones_totales),
                horizon=13,
                number_of_folds=1,
                model.function=function(data_train) {
                  m_ser <- prophet(yearly.seasonality=10,
                                   weekly.seasonality=FALSE,
                                   daily.seasonality=FALSE,
                                   seasonality.prior.scale=10, #10
                                   changepoint.prior.scale=0.05) #0.05
                  m_ser <- add_seasonality(m_ser, name='monthly', period=30.5,
                                           fourier.order=8, prior.scale=10) #10
                  m_ser <- add_regressor(m_ser, 'otros_precio_medio', prior.scale=5) #5
                  m_ser <- add_regressor(m_ser, 'trafico_web_sesiones_totales', prior.scale=5) #5
                  m_ser <- fit.prophet(m_ser, 
                                       train %>%
                                         select(ds=Fecha, y=ventas_online_uds,
                                                otros_precio_medio, trafico_web_sesiones_totales))
                  return(m_ser)
                },
                do.plot=TRUE,
                verbose=TRUE,
                debug=TRUE)


# 1. CV grid piors 2 variables explicativas
res_df1 <- c()
for (prior_scale_1 in c(0.01, 0.1, 1, 5, 10)) {
  for (prior_scale_2 in c(0.01, 0.1, 1, 5, 10)) {
    res <- prophet.cv.loop(tb_weekly_base %>% 
                             mutate(Fecha=as.POSIXct(Fecha)) %>%
                             select(ds=Fecha, y=ventas_online_uds,
                                    otros_precio_medio, trafico_web_sesiones_totales),
                           horizon=13,
                           number_of_folds=1,
                           model.function=function(data_train) {
                             m_ser <- prophet(yearly.seasonality=10,
                                              weekly.seasonality=FALSE,
                                              daily.seasonality=FALSE,
                                              seasonality.prior.scale=10, #10
                                              changepoint.prior.scale=0.05) #0.05
                             m_ser <- add_seasonality(m_ser, name='monthly', period=30.5,
                                                      fourier.order=8, prior.scale=10) #10
                             m_ser <- add_regressor(m_ser, 'otros_precio_medio', 
                                                    prior.scale=prior_scale_1) #5
                             m_ser <- add_regressor(m_ser, 'trafico_web_sesiones_totales', 
                                                    prior.scale=prior_scale_2) #5
                             m_ser <- fit.prophet(m_ser, 
                                                  train %>%
                                                    select(ds=Fecha, y=ventas_online_uds,
                                                           otros_precio_medio, trafico_web_sesiones_totales))
                             return(m_ser)
                           },
                           do.plot=FALSE,
                           verbose=FALSE,
                           debug=FALSE)
    print(paste0("prior_scale_1: ", prior_scale_1,
                 " / prior_scale_2: ", prior_scale_2,
                 ": mape: ", mean(res$mape)))
    res_row <- data.frame(prior_scale_1=prior_scale_1,
                          prior_scale_2=prior_scale_2,
                          mean_mape=mean(res$mape))
    res_df1 <- rbind(res_df1, res_row)
  }
}
res_df1
res_df1[res_df1$mean_mape <= min(res_df1$mean_mape)*1.001 &
          res_df1$mean_mape >= min(res_df1$mean_mape)*0.999,]


# 2. CV grid piors 2 variables explicativas + seasonality
res_df2 <- c()
for (prior_scale_1 in c(0.01, 0.1, 1, 5, 10)) {
  for (prior_scale_2 in c(0.01, 0.1, 1, 5, 10)) {
    for (seasonality_prior_scale in c(0.1, 1, 5, 10, 20)) {
      for (changepoint_prior_scale in c(0.01, 0.05, 0.1, 0.5, 1)) {
        for (monthly_prior_scale in c(0.1, 1, 5, 10, 20)) {
          res <- prophet.cv.loop(tb_weekly_base %>% 
                                   mutate(Fecha=as.POSIXct(Fecha)) %>%
                                   select(ds=Fecha, y=ventas_online_uds,
                                          otros_precio_medio, trafico_web_sesiones_totales),
                                 horizon=13,
                                 number_of_folds=1,
                                 model.function=function(data_train) {
                                   m_ser <- prophet(yearly.seasonality=10,
                                                    weekly.seasonality=FALSE,
                                                    daily.seasonality=FALSE,
                                                    seasonality.prior.scale=seasonality_prior_scale, #10
                                                    changepoint.prior.scale=changepoint_prior_scale) #0.05
                                   m_ser <- add_seasonality(m_ser, name='monthly', period=30.5,
                                                            fourier.order=8, prior.scale=monthly_prior_scale) #10
                                   m_ser <- add_regressor(m_ser, 'otros_precio_medio', 
                                                          prior.scale=prior_scale_1) #5
                                   m_ser <- add_regressor(m_ser, 'trafico_web_sesiones_totales', 
                                                          prior.scale=prior_scale_2) #5
                                   m_ser <- fit.prophet(m_ser, 
                                                        train %>%
                                                          select(ds=Fecha, y=ventas_online_uds,
                                                                 otros_precio_medio, trafico_web_sesiones_totales))
                                   return(m_ser)
                                 },
                                 do.plot=FALSE,
                                 verbose=FALSE,
                                 debug=FALSE)
          print(paste0("prior_scale_1: ", prior_scale_1,
                       " / prior_scale_2: ", prior_scale_2,
                       " / seasonality_prior_scale: ", seasonality_prior_scale,
                       " / changepoint_prior_scale: ", changepoint_prior_scale,
                       " / monthly_prior_scale: ", monthly_prior_scale,
                       ": mape: ", mean(res$mape)))
          res_row <- data.frame(prior_scale_1=prior_scale_1,
                                prior_scale_2=prior_scale_2,
                                seasonality_prior_scale=seasonality_prior_scale,
                                changepoint_prior_scale=changepoint_prior_scale,
                                monthly_prior_scale=monthly_prior_scale,
                                mean_mape=mean(res$mape))
          res_df2 <- rbind(res_df2, res_row)
        }
      }
    }
  }
}
res_df2
res_df2[res_df2$mean_mape <= min(res_df2$mean_mape)*1.001 &
          res_df2$mean_mape >= min(res_df2$mean_mape)*0.999,]
write.csv(res_df2, file="res_df2.csv", row.names=FALSE)



